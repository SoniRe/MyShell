EXIT_SUCCESS - Same as exit(0) but Guarantees work on Cross Platforms

int main(int ac, char **av) -> Taking Argument and automatically making tokenList and storing in av, also ac for argument count

execvp() - Replaces current process image with other
Eg: 	char *args[] = {"ls", "-l", "/home", NULL};
	execvp("ls", args);

Enter The line : (Using getline)
1) Parse It 
2) Divide into tokens
3) Create Vector of Tokens 

readline(&buffer, &buffer_size) - Same as getline() provides editing , history and more perfect for shell

size_t() - Unsigned Integer for Cross Platforms

feof(FILE *stream) - Checks EOF reached if yes EOF Flag is set

getcwd(buffer, buffer_size) - Gives the absolute path of current directory

token = strtok(line, delimeter) - Gives back first token for the line/Command. 
Using second time just use strtok(NULL, delimeter) as continues to get tokens from the same string

Sentinel Value is NULL, at the end of tokensList. Eg: char *tokensList[] = {"ls", "-l", NULL};

executeCommand(args) -> If Builtin shell(echo, env, exit just call) else fork() -> execvp() -> wait() 

extern char **environ -> Used to find all environment variables

Necessary Functionalities Added:
1) I/O Redirection
2) Pipes
3) Background Process (&)
4) Signal Handling (Ctrl + Z) or (Ctrl + C)
5) Interactive Flow , command history and Tab Completion

I/O Redirection ->

int saved_stdin = dup(STDIN_FILENO)
dup2(Source, Destination)

O_TRUNC - Deletes all data inside file and make it empty
open(file, O_WRONLY | O_TRUNC, 0777)

0777(Octal Value) = Enabled for all users 

GNU readline() ->

char prompt[40];
snprintf(prompt, sizeof(prompt), "Enter the command %s:", "Aditya"); // Enter the command Aditya -> stored in prompt

char *line = readline(prompt); 
Doesn't include \n as input, breaks when pressed enter comes with tab completion for files and add_history() function.

Pipes -> 

